{"version":3,"file":"easy-peasy.umd.js","sources":["../src/context.js","../src/hooks.js","../src/constants.js","../src/helpers.js","../src/lib.js","../src/create-reducer.js","../src/persistence.js","../src/actions.js","../src/thunks.js","../src/extract-data-from-model.js","../src/listeners.js","../src/computed-properties.js","../src/create-store.js","../src/create-store-internals.js","../src/index.js","../src/provider.js","../src/create-component-store.js","../src/create-context-store.js","../src/create-transform.js"],"sourcesContent":["import { createContext } from 'react';\n\nconst StoreContext = createContext();\n\nexport default StoreContext;\n","import {\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useReducer,\n  useRef,\n  useState,\n} from 'react';\nimport EasyPeasyContext from './context';\n\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\nconst useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n\nexport function createStoreStateHook(Context) {\n  return function useStoreState(mapState, equalityFn) {\n    const store = useContext(Context);\n    const mapStateRef = useRef(mapState);\n    const stateRef = useRef();\n    const mountedRef = useRef(true);\n    const subscriptionMapStateError = useRef();\n\n    const [, forceRender] = useReducer(s => s + 1, 0);\n\n    if (\n      subscriptionMapStateError.current ||\n      mapStateRef.current !== mapState ||\n      stateRef.current === undefined\n    ) {\n      try {\n        stateRef.current = mapState(store.getState());\n      } catch (err) {\n        if (process.env.NODE_ENV === 'development') {\n          let errorMessage = `An error occurred trying to map state in a useStoreState hook: ${err.message}.`;\n          if (subscriptionMapStateError.current) {\n            errorMessage += `\\nThis error may be related to the following error:\\n${subscriptionMapStateError.current.stack}\\n\\nOriginal stack trace:`;\n          }\n          throw new Error(errorMessage);\n        }\n        throw subscriptionMapStateError.current || err;\n      }\n    }\n\n    useIsomorphicLayoutEffect(() => {\n      mapStateRef.current = mapState;\n      subscriptionMapStateError.current = undefined;\n    });\n\n    useIsomorphicLayoutEffect(() => {\n      const checkMapState = () => {\n        try {\n          const newState = mapStateRef.current(store.getState());\n\n          const isStateEqual =\n            typeof equalityFn === 'function'\n              ? equalityFn(stateRef.current, newState)\n              : stateRef.current === newState;\n\n          if (isStateEqual) {\n            return;\n          }\n\n          stateRef.current = newState;\n        } catch (err) {\n          // see https://github.com/reduxjs/react-redux/issues/1179\n          // There is a possibility mapState will fail due to stale state or\n          // props, therefore we will just track the error and force our\n          // component to update. It should then receive the updated state\n          subscriptionMapStateError.current = err;\n        }\n        if (mountedRef.current) {\n          forceRender({});\n        }\n      };\n      const unsubscribe = store.subscribe(checkMapState);\n      checkMapState();\n      return () => {\n        mountedRef.current = false;\n        unsubscribe();\n      };\n    }, []);\n\n    return stateRef.current;\n  };\n}\n\nexport const useStoreState = createStoreStateHook(EasyPeasyContext);\n\nexport function createStoreActionsHook(Context) {\n  return function useStoreActions(mapActions) {\n    const store = useContext(Context);\n    return mapActions(store.getActions());\n  };\n}\n\nexport const useStoreActions = createStoreActionsHook(EasyPeasyContext);\n\nexport function createStoreDispatchHook(Context) {\n  return function useStoreDispatch() {\n    const store = useContext(Context);\n    return store.dispatch;\n  };\n}\n\nexport const useStoreDispatch = createStoreDispatchHook(EasyPeasyContext);\n\nexport function useStore() {\n  return useContext(EasyPeasyContext);\n}\n\nexport function createStoreRehydratedHook(Context) {\n  return function useStoreRehydrated() {\n    const store = useContext(Context);\n    const [rehydrated, setRehydrated] = useState(false);\n    useEffect(() => {\n      store.persist.resolveRehydration().then(() => setRehydrated(true));\n    }, []);\n    return rehydrated;\n  };\n}\n\nexport const useStoreRehydrated = createStoreRehydratedHook(EasyPeasyContext);\n\nexport function createTypedHooks() {\n  return {\n    useStoreActions,\n    useStoreDispatch,\n    useStoreState,\n    useStoreRehydrated,\n    useStore,\n  };\n}\n","export const actionSymbol = 'a';\nexport const actionOnSymbol = 'aO';\nexport const computedSymbol = 'c';\nexport const persistSymbol = 'p';\nexport const reducerSymbol = 'r';\nexport const thunkOnSymbol = 'tO';\nexport const thunkSymbol = 't';\n","import { isDraft, original } from 'immer-peasy';\nimport memoizerific from 'memoizerific';\nimport {\n  actionOnSymbol,\n  actionSymbol,\n  computedSymbol,\n  persistSymbol,\n  reducerSymbol,\n  thunkOnSymbol,\n  thunkSymbol,\n} from './constants';\n\nexport const debug = state => {\n  if (isDraft(state)) {\n    return original(state);\n  }\n  return state;\n};\n\nexport const memo = (fn, cacheSize) => memoizerific(cacheSize)(fn);\n\nexport const actionOn = (targetResolver, fn) => {\n  fn[actionOnSymbol] = {\n    targetResolver,\n  };\n  return fn;\n};\n\nexport const action = fn => {\n  fn[actionSymbol] = {};\n  return fn;\n};\n\nconst defaultStateResolvers = [state => state];\n\nexport const computed = (fnOrStateResolvers, fn) => {\n  if (typeof fn === 'function') {\n    fn[computedSymbol] = {\n      stateResolvers: fnOrStateResolvers,\n    };\n    return fn;\n  }\n  fnOrStateResolvers[computedSymbol] = {\n    stateResolvers: defaultStateResolvers,\n  };\n  return fnOrStateResolvers;\n};\n\nexport const persist = (model, config) => {\n  return {\n    ...model,\n    [persistSymbol]: config,\n  };\n};\n\nexport const thunkOn = (targetResolver, fn) => {\n  fn[thunkOnSymbol] = {\n    targetResolver,\n  };\n  return fn;\n};\n\nexport const thunk = fn => {\n  fn[thunkSymbol] = {};\n  return fn;\n};\n\nexport const reducer = fn => {\n  fn[reducerSymbol] = {};\n  return fn;\n};\n","import isPlainObject from 'is-plain-object';\nimport { createDraft, finishDraft, isDraft } from 'immer-peasy';\n\nexport const deepCloneStateWithoutComputed = source => {\n  const recursiveClone = current => {\n    const next = Object.keys(current).reduce((acc, key) => {\n      if (Object.getOwnPropertyDescriptor(current, key).get == null) {\n        acc[key] = current[key];\n      }\n      return acc;\n    }, {});\n    Object.keys(next).forEach(key => {\n      if (isPlainObject(next[key])) {\n        next[key] = recursiveClone(next[key]);\n      }\n    });\n    return next;\n  };\n  return recursiveClone(source);\n};\n\nexport const isPromise = x => {\n  return x != null && typeof x === 'object' && typeof x.then === 'function';\n};\n\nexport function get(path, target) {\n  return path.reduce((acc, cur) => {\n    return isPlainObject(acc) ? acc[cur] : undefined;\n  }, target);\n}\n\nexport function newify(currentPath, currentState, finalValue) {\n  if (currentPath.length === 0) {\n    return finalValue;\n  }\n  const newState = { ...currentState };\n  const key = currentPath[0];\n  if (currentPath.length === 1) {\n    newState[key] = finalValue;\n  } else {\n    newState[key] = newify(currentPath.slice(1), newState[key], finalValue);\n  }\n  return newState;\n}\n\nexport const set = (path, target, value) => {\n  if (path.length === 0) {\n    if (typeof value === 'object') {\n      Object.keys(target).forEach(key => {\n        delete target[key];\n      });\n      Object.keys(value).forEach(key => {\n        target[key] = value[key];\n      });\n    }\n    return;\n  }\n  path.reduce((acc, cur, idx) => {\n    if (idx + 1 === path.length) {\n      acc[cur] = value;\n    } else {\n      acc[cur] = acc[cur] || {};\n    }\n    return acc[cur];\n  }, target);\n};\n\nexport function createSimpleProduce(disableImmer = false) {\n  return function simpleProduce(path, state, fn) {\n    if (disableImmer) {\n      const current = get(path, state);\n      const next = fn(current);\n      if (current !== next) {\n        return newify(path, state, next);\n      }\n      return state;\n    }\n    if (path.length === 0) {\n      const draft = createDraft(state);\n      const result = fn(draft);\n      if (result) {\n        return isDraft(result) ? finishDraft(result) : result;\n      }\n      return finishDraft(draft);\n    }\n    const parentPath = path.slice(0, path.length - 1);\n    const draft = createDraft(state);\n    const parent = get(parentPath, state);\n    const current = get(path, draft);\n    const result = fn(current);\n\n    if (result) {\n      parent[path[path.length - 1]] = result;\n    }\n    return finishDraft(draft);\n  };\n}\n","import { createSimpleProduce, get } from './lib';\nimport { actionSymbol, actionOnSymbol } from './constants';\n\nexport default function createReducer(\n  disableImmer,\n  actionReducersDict,\n  customReducers,\n  computedProperties,\n) {\n  const simpleProduce = createSimpleProduce(disableImmer);\n\n  const runActionReducerAtPath = (state, action, actionReducer, path) => {\n    return simpleProduce(path, state, draft =>\n      actionReducer(draft, action.payload),\n    );\n  };\n\n  const reducerForActions = (state, action) => {\n    const actionReducer = actionReducersDict[action.type];\n    if (actionReducer) {\n      const actionMeta =\n        actionReducer[actionSymbol] || actionReducer[actionOnSymbol];\n      return runActionReducerAtPath(\n        state,\n        action,\n        actionReducer,\n        actionMeta.parent,\n      );\n    }\n    return state;\n  };\n\n  const reducerForCustomReducers = (state, action) => {\n    return customReducers.reduce((acc, { parentPath, key, reducer: red }) => {\n      return simpleProduce(parentPath, acc, draft => {\n        draft[key] = red(draft[key], action);\n        return draft;\n      });\n    }, state);\n  };\n\n  const rootReducer = (state, action) => {\n    const stateAfterActions = reducerForActions(state, action);\n    const next =\n      customReducers.length > 0\n        ? reducerForCustomReducers(stateAfterActions, action)\n        : stateAfterActions;\n    if (state !== next) {\n      computedProperties.forEach(({ parentPath, bindComputedProperty }) => {\n        const prop = get(parentPath, next);\n        if (prop) bindComputedProperty(prop);\n      });\n    }\n    return next;\n  };\n\n  return rootReducer;\n}\n","import debounce from 'debounce';\nimport isPlainObject from 'is-plain-object';\nimport { deepCloneStateWithoutComputed, get, isPromise, set } from './lib';\n\nconst noopStorage = {\n  getItem: () => undefined,\n  setItem: () => undefined,\n  removeItem: () => undefined,\n};\n\nfunction getStorage(storageName) {\n  try {\n    if (\n      typeof window !== 'undefined' &&\n      typeof window[storageName] !== 'undefined'\n    ) {\n      return window[storageName];\n    }\n    return noopStorage;\n  } catch (_) {\n    return noopStorage;\n  }\n}\n\nconst localStorage = getStorage('localStorage');\nconst sessionStorage = getStorage('sessionStorage');\n\nfunction createStorageWrapper(storage = sessionStorage, transformers = []) {\n  if (typeof storage === 'string') {\n    if (storage === 'localStorage') {\n      storage = localStorage;\n    } else if (storage === 'sessionStorage') {\n      storage = sessionStorage;\n    } else {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(\n          `Invalid storage provider specified for Easy Peasy persist: ${storage}\\nValid values include \"localStorage\", \"sessionStorage\" or a custom storage engine.`,\n        );\n      }\n      storage = noopStorage;\n    }\n  }\n\n  const outTransformers = transformers.reverse();\n\n  const serialize = (data, key) => {\n    const simpleKey = key.substr(key.indexOf('@') + 1);\n    const transformed = transformers.reduce((acc, cur) => {\n      return cur.in(acc, simpleKey);\n    }, data);\n    return storage === localStorage || storage === sessionStorage\n      ? JSON.stringify({ data: transformed })\n      : transformed;\n  };\n  const deserialize = (data, key) => {\n    const simpleKey = key.substr(key.indexOf('@') + 1);\n    const result =\n      storage === localStorage || storage === sessionStorage\n        ? JSON.parse(data).data\n        : data;\n    return outTransformers.reduce((acc, cur) => {\n      return cur.out(acc, simpleKey);\n    }, result);\n  };\n\n  const isAsync = isPromise(storage.getItem('_'));\n\n  return {\n    isAsync,\n    getItem: key => {\n      if (isAsync) {\n        return storage.getItem(key).then(wrapped => {\n          return wrapped != null ? deserialize(wrapped, key) : undefined;\n        });\n      }\n      const wrapped = storage.getItem(key);\n      return wrapped != null ? deserialize(wrapped, key) : undefined;\n    },\n    setItem: (key, data) => {\n      return storage.setItem(key, serialize(data, key));\n    },\n    removeItem: key => {\n      return storage.removeItem(key);\n    },\n  };\n}\n\nexport function extractPersistConfig(path, persistDefinition = {}) {\n  return {\n    path,\n    config: {\n      blacklist: persistDefinition.blacklist || [],\n      mergeStrategy: persistDefinition.mergeStrategy || 'merge',\n      storage: createStorageWrapper(\n        persistDefinition.storage,\n        persistDefinition.transformers,\n      ),\n      whitelist: persistDefinition.whitelist || [],\n    },\n  };\n}\n\nfunction resolvePersistTargets(target, whitelist, blacklist) {\n  let targets = Object.keys(target);\n  if (whitelist.length > 0) {\n    targets = targets.reduce((acc, cur) => {\n      if (whitelist.findIndex(x => x === cur) !== -1) {\n        return [...acc, cur];\n      }\n      return acc;\n    }, []);\n  }\n  if (blacklist.length > 0) {\n    targets = targets.reduce((acc, cur) => {\n      if (blacklist.findIndex(x => x === cur) !== -1) {\n        return acc;\n      }\n      return [...acc, cur];\n    }, []);\n  }\n  return targets;\n}\n\nexport function createPersistor(persistKey, references) {\n  return debounce(() => {\n    references.internals.persistenceConfig.forEach(({ path, config }) => {\n      const { storage, whitelist, blacklist } = config;\n      const state = references.getState();\n      const persistRoot = deepCloneStateWithoutComputed(get(path, state));\n      const targets = resolvePersistTargets(persistRoot, whitelist, blacklist);\n      targets.forEach(key => {\n        const targetPath = [...path, key];\n        storage.setItem(persistKey(targetPath), get(targetPath, state));\n      });\n    });\n  }, 1000);\n}\n\nexport function createPersistMiddleware(persistor, references) {\n  return () => next => action => {\n    const state = next(action);\n    if (\n      action &&\n      action.type !== '@action.ePRS' &&\n      references.internals.persistenceConfig.length > 0\n    ) {\n      persistor(state);\n    }\n    return state;\n  };\n}\n\nexport function createPersistenceClearer(persistKey, references) {\n  return () =>\n    new Promise((resolve, reject) => {\n      references.internals.persistenceConfig.forEach(({ path, config }) => {\n        const { storage, whitelist, blacklist } = config;\n        const persistRoot = get(path, references.getState());\n        const targets = resolvePersistTargets(\n          persistRoot,\n          whitelist,\n          blacklist,\n        );\n        if (targets.length > 0) {\n          Promise.all(\n            targets.map(key => {\n              const targetPath = [...path, key];\n              return storage.removeItem(persistKey(targetPath));\n            }),\n          ).then(() => resolve(), reject);\n        } else {\n          resolve();\n        }\n      });\n    });\n}\n\nexport function rehydrateStateFromPersistIfNeeded(\n  persistKey,\n  replaceState,\n  references,\n) {\n  // If we have any persist configs we will attemp to perform a state rehydration\n  let resolveRehydration = Promise.resolve();\n  if (references.internals.persistenceConfig.length > 0) {\n    references.internals.persistenceConfig.forEach(persistInstance => {\n      const { path, config } = persistInstance;\n      const { blacklist, mergeStrategy, storage, whitelist } = config;\n\n      const state = references.internals.defaultState;\n      const persistRoot = deepCloneStateWithoutComputed(get(path, state));\n      const targets = resolvePersistTargets(persistRoot, whitelist, blacklist);\n\n      const applyRehydrationStrategy = (originalState, rehydratedState) => {\n        if (mergeStrategy === 'overwrite') {\n          set(path, originalState, rehydratedState);\n        } else if (mergeStrategy === 'merge') {\n          const target = get(path, originalState);\n          Object.keys(rehydratedState).forEach(key => {\n            target[key] = rehydratedState[key];\n          });\n        } else if (mergeStrategy === 'mergeDeep') {\n          const target = get(path, originalState);\n          const setAt = (currentTarget, currentNext) => {\n            Object.keys(currentNext).forEach(key => {\n              const data = currentNext[key];\n              if (isPlainObject(data)) {\n                if (!isPlainObject(currentTarget[key])) {\n                  currentTarget[key] = {};\n                }\n                setAt(currentTarget[key], data);\n              } else {\n                currentTarget[key] = data;\n              }\n            });\n          };\n          setAt(target, rehydratedState);\n        }\n      };\n\n      if (storage.isAsync) {\n        const asyncStateResolvers = targets.reduce((acc, key) => {\n          const targetPath = [...path, key];\n          const dataPromise = storage.getItem(persistKey(targetPath));\n          if (isPromise(dataPromise)) {\n            acc.push({\n              key,\n              dataPromise,\n            });\n          }\n          return acc;\n        }, []);\n        if (asyncStateResolvers.length > 0) {\n          resolveRehydration = Promise.all(\n            asyncStateResolvers.map(x => x.dataPromise),\n          ).then(resolvedData => {\n            const next = resolvedData.reduce((acc, cur, idx) => {\n              const { key } = asyncStateResolvers[idx];\n              if (cur !== undefined) {\n                acc[key] = cur;\n              }\n              return acc;\n            }, {});\n            if (Object.keys(next).length === 0) {\n              return;\n            }\n            applyRehydrationStrategy(state, next);\n            replaceState(state);\n          });\n        }\n      } else {\n        const next = targets.reduce((acc, key) => {\n          const targetPath = [...path, key];\n          const data = storage.getItem(persistKey(targetPath));\n          if (data !== undefined) {\n            acc[key] = data;\n          }\n          return acc;\n        }, {});\n        applyRehydrationStrategy(state, next);\n        replaceState(state);\n      }\n    });\n  }\n  return resolveRehydration;\n}\n","import { actionSymbol, actionOnSymbol } from './constants';\n\nexport function createActionCreator(actionDefinition, meta, references) {\n  const prefix = actionDefinition[actionSymbol] ? '@action' : '@actionOn';\n  const type = `${prefix}.${meta.path.join('.')}`;\n  const actionMeta =\n    actionDefinition[actionSymbol] || actionDefinition[actionOnSymbol];\n  actionMeta.actionName = meta.key;\n  actionMeta.type = type;\n  actionMeta.parent = meta.parent;\n  actionMeta.path = meta.path;\n\n  const actionCreator = payload => {\n    const action = {\n      type,\n      payload,\n    };\n    if (actionDefinition[actionOnSymbol] && actionMeta.resolvedTargets) {\n      payload.resolvedTargets = [...actionMeta.resolvedTargets];\n    }\n    const result = references.dispatch(action);\n    return result;\n  };\n  actionCreator.type = type;\n\n  return actionCreator;\n}\n","import { thunkSymbol, thunkOnSymbol } from './constants';\nimport { get, isPromise } from './lib';\n\nexport function createThunkHandler(\n  thunkDefinition,\n  meta,\n  references,\n  injections,\n  actionCreators,\n) {\n  const thunkMeta =\n    thunkDefinition[thunkSymbol] || thunkDefinition[thunkOnSymbol];\n\n  return payload => {\n    const helpers = {\n      dispatch: references.dispatch,\n      getState: () => get(meta.parent, references.getState()),\n      getStoreActions: () => actionCreators,\n      getStoreState: references.getState,\n      injections,\n      meta,\n    };\n    if (thunkDefinition[thunkOnSymbol] && thunkMeta.resolvedTargets) {\n      payload.resolvedTargets = [...thunkMeta.resolvedTargets];\n    }\n    return thunkDefinition(get(meta.parent, actionCreators), payload, helpers);\n  };\n}\n\nexport function createThunkActionsCreator(\n  thunkDefinition,\n  meta,\n  references,\n  thunkHandler,\n) {\n  const prefix = thunkDefinition[thunkSymbol] ? '@thunk' : '@thunkOn';\n  const type = `${prefix}.${meta.path.join('.')}`;\n  const startType = `${type}(start)`;\n  const successType = `${type}(success)`;\n  const failType = `${type}(fail)`;\n\n  const thunkMeta =\n    thunkDefinition[thunkSymbol] || thunkDefinition[thunkOnSymbol];\n  thunkMeta.type = type;\n  thunkMeta.actionName = meta.key;\n  thunkMeta.parent = meta.parent;\n  thunkMeta.path = meta.path;\n\n  const actionCreator = payload => {\n    const dispatchError = err => {\n      references.dispatch({\n        type: failType,\n        payload,\n        error: err,\n      });\n      references.dispatch({\n        type,\n        payload,\n        error: err,\n      });\n    };\n    const dispatchSuccess = result => {\n      references.dispatch({\n        type: successType,\n        payload,\n        result,\n      });\n      references.dispatch({\n        type,\n        payload,\n        result,\n      });\n    };\n\n    references.dispatch({\n      type: startType,\n      payload,\n    });\n    try {\n      const result = references.dispatch(() => thunkHandler(payload));\n      if (isPromise(result)) {\n        return result\n          .then(resolved => {\n            dispatchSuccess(resolved);\n            return resolved;\n          })\n          .catch(err => {\n            dispatchError(err);\n            throw err;\n          });\n      }\n      dispatchSuccess(result);\n      return result;\n    } catch (err) {\n      dispatchError(err);\n      throw err;\n    }\n  };\n\n  actionCreator.type = type;\n  actionCreator.startType = startType;\n  actionCreator.successType = successType;\n  actionCreator.failType = failType;\n\n  return actionCreator;\n}\n","import isPlainObject from 'is-plain-object';\nimport {\n  actionOnSymbol,\n  actionSymbol,\n  computedSymbol,\n  persistSymbol,\n  reducerSymbol,\n  thunkOnSymbol,\n  thunkSymbol,\n} from './constants';\nimport { get, set } from './lib';\nimport { extractPersistConfig } from './persistence';\nimport { createActionCreator } from './actions';\nimport { createThunkHandler, createThunkActionsCreator } from './thunks';\nimport { bindListenerDefinitions } from './listeners';\nimport { createComputedPropertyBinder } from './computed-properties';\n\nexport default function extractDataFromModel(\n  model,\n  initialState,\n  injections,\n  references,\n) {\n  const defaultState = initialState;\n  const actionCreatorDict = {};\n  const actionCreators = {};\n  const actionReducersDict = {};\n  const actionThunks = {};\n  const computedProperties = [];\n  const customReducers = [];\n  const listenerActionCreators = {};\n  const listenerActionMap = {};\n  const listenerDefinitions = [];\n  const persistenceConfig = [];\n  const computedState = {\n    isInReducer: false,\n    currentState: defaultState,\n  };\n\n  const recursiveExtractFromModel = (current, parentPath) =>\n    Object.keys(current).forEach(key => {\n      const value = current[key];\n      const path = [...parentPath, key];\n      const meta = {\n        parent: parentPath,\n        path,\n        key,\n      };\n      const handleValueAsState = () => {\n        const initialParentRef = get(parentPath, initialState);\n        if (initialParentRef && key in initialParentRef) {\n          set(path, defaultState, initialParentRef[key]);\n        } else {\n          set(path, defaultState, value);\n        }\n      };\n\n      if (key === persistSymbol) {\n        persistenceConfig.push(extractPersistConfig(parentPath, value));\n        return;\n      }\n\n      if (typeof value === 'function') {\n        if (value[actionSymbol] || value[actionOnSymbol]) {\n          const actionReducer = value;\n          const actionCreator = createActionCreator(value, meta, references);\n          actionCreatorDict[actionCreator.type] = actionCreator;\n          actionReducersDict[actionCreator.type] = actionReducer;\n          if (meta.key !== 'ePRS') {\n            if (value[actionOnSymbol]) {\n              listenerDefinitions.push(value);\n              set(path, listenerActionCreators, actionCreator);\n            } else {\n              set(path, actionCreators, actionCreator);\n            }\n          }\n        } else if (value[thunkSymbol] || value[thunkOnSymbol]) {\n          const thunkHandler = createThunkHandler(\n            value,\n            meta,\n            references,\n            injections,\n            actionCreators,\n          );\n          const actionCreator = createThunkActionsCreator(\n            value,\n            meta,\n            references,\n            thunkHandler,\n          );\n          set(path, actionThunks, thunkHandler);\n          actionCreatorDict[actionCreator.type] = actionCreator;\n          if (value[thunkOnSymbol]) {\n            listenerDefinitions.push(value);\n            set(path, listenerActionCreators, actionCreator);\n          } else {\n            set(path, actionCreators, actionCreator);\n          }\n        } else if (value[computedSymbol]) {\n          const parent = get(parentPath, defaultState);\n          const bindComputedProperty = createComputedPropertyBinder(\n            parentPath,\n            key,\n            value,\n            computedState,\n            references,\n          );\n          bindComputedProperty(parent);\n          computedProperties.push({ key, parentPath, bindComputedProperty });\n        } else if (value[reducerSymbol]) {\n          customReducers.push({ key, parentPath, reducer: value });\n        } else {\n          handleValueAsState();\n        }\n      } else if (isPlainObject(value)) {\n        const existing = get(path, defaultState);\n        if (existing == null) {\n          set(path, defaultState, {});\n        }\n        recursiveExtractFromModel(value, path);\n      } else {\n        handleValueAsState();\n      }\n    });\n\n  recursiveExtractFromModel(model, []);\n\n  bindListenerDefinitions(\n    listenerDefinitions,\n    actionCreators,\n    actionCreatorDict,\n    listenerActionMap,\n  );\n\n  return {\n    actionCreatorDict,\n    actionCreators,\n    actionReducersDict,\n    computedProperties,\n    customReducers,\n    computedState,\n    defaultState,\n    listenerActionCreators,\n    listenerActionMap,\n    persistenceConfig,\n  };\n}\n","import { actionOnSymbol, thunkOnSymbol } from './constants';\nimport { get } from './lib';\n\nexport function createListenerMiddleware(references) {\n  return () => next => action => {\n    const result = next(action);\n    if (\n      action &&\n      references.internals.listenerActionMap[action.type] &&\n      references.internals.listenerActionMap[action.type].length > 0\n    ) {\n      const sourceAction = references.internals.actionCreatorDict[action.type];\n      references.internals.listenerActionMap[action.type].forEach(\n        actionCreator => {\n          actionCreator({\n            type: sourceAction ? sourceAction.type : action.type,\n            payload: action.payload,\n            error: action.error,\n            result: action.result,\n          });\n        },\n      );\n    }\n    return result;\n  };\n}\n\nexport function bindListenerDefinitions(\n  listenerDefinitions,\n  actionCreators,\n  actionCreatorDict,\n  listenerActionMap,\n) {\n  listenerDefinitions.forEach(listenerActionOrThunk => {\n    const listenerMeta =\n      listenerActionOrThunk[actionOnSymbol] ||\n      listenerActionOrThunk[thunkOnSymbol];\n\n    const targets = listenerMeta.targetResolver(\n      get(listenerMeta.parent, actionCreators),\n      actionCreators,\n    );\n    const targetTypes = (Array.isArray(targets) ? targets : [targets]).reduce(\n      (acc, target) => {\n        if (\n          typeof target === 'function' &&\n          target.type &&\n          actionCreatorDict[target.type]\n        ) {\n          acc.push(target.type);\n        } else if (typeof target === 'string') {\n          acc.push(target);\n        }\n        return acc;\n      },\n      [],\n    );\n\n    listenerMeta.resolvedTargets = targetTypes;\n\n    targetTypes.forEach(targetType => {\n      const listenerReg = listenerActionMap[targetType] || [];\n      listenerReg.push(actionCreatorDict[listenerMeta.type]);\n      listenerActionMap[targetType] = listenerReg;\n    });\n  });\n}\n","import memoizerific from 'memoizerific';\nimport { get } from './lib';\nimport { computedSymbol } from './constants';\n\nexport function createComputedPropertyBinder(\n  parentPath,\n  key,\n  definition,\n  computedState,\n  references,\n) {\n  const computedMeta = definition[computedSymbol];\n  const memoisedResultFn = memoizerific(1)(definition);\n  return function createComputedProperty(o) {\n    Object.defineProperty(o, key, {\n      configurable: true,\n      enumerable: true,\n      get: () => {\n        let storeState;\n        if (computedState.isInReducer) {\n          storeState = computedState.currentState;\n        } else if (references.getState == null) {\n          return undefined;\n        } else {\n          try {\n            storeState = references.getState();\n          } catch (err) {\n            if (process.env.NODE_ENV === 'development') {\n              console.warn('Invalid access attempt to a computed property');\n            }\n            return undefined;\n          }\n        }\n        const state = get(parentPath, storeState);\n        const inputs = computedMeta.stateResolvers.map(resolver =>\n          resolver(state, storeState),\n        );\n        return memoisedResultFn(...inputs);\n      },\n    });\n  };\n}\n\nexport function createComputedPropertiesMiddleware(references) {\n  return store => next => action => {\n    references.internals.computedState.currentState = store.getState();\n    references.internals.computedState.isInReducer = true;\n    return next(action);\n  };\n}\n","import {\n  applyMiddleware,\n  compose as reduxCompose,\n  createStore as reduxCreateStore,\n} from 'redux';\nimport reduxThunk from 'redux-thunk';\nimport * as helpers from './helpers';\nimport createStoreInternals from './create-store-internals';\nimport {\n  createPersistor,\n  createPersistMiddleware,\n  createPersistenceClearer,\n  rehydrateStateFromPersistIfNeeded,\n} from './persistence';\nimport { createComputedPropertiesMiddleware } from './computed-properties';\nimport { createListenerMiddleware } from './listeners';\nimport { deepCloneStateWithoutComputed } from './lib';\n\nexport default function createStore(model, options = {}) {\n  const modelClone = deepCloneStateWithoutComputed(model);\n  const {\n    compose,\n    devTools = true,\n    disableImmer = false,\n    enhancers = [],\n    initialState = {},\n    injections,\n    middleware = [],\n    mockActions = false,\n    name: storeName = `EasyPeasyStore`,\n    reducerEnhancer = rootReducer => rootReducer,\n  } = options;\n\n  const bindReplaceState = modelDef => {\n    return {\n      ...modelDef,\n      ePRS: helpers.action((_, payload) => payload),\n    };\n  };\n\n  const references = {};\n\n  let modelDefinition = bindReplaceState(modelClone);\n  let mockedActions = [];\n\n  const persistKey = targetPath => `[${storeName}]@${targetPath.join('.')}`;\n  const persistor = createPersistor(persistKey, references);\n  const persistMiddleware = createPersistMiddleware(persistor, references);\n  const clearPersistance = createPersistenceClearer(persistKey, references);\n\n  const replaceState = nextState =>\n    references.internals.actionCreatorDict['@action.ePRS'](nextState);\n\n  const bindStoreInternals = (state = {}) => {\n    references.internals = createStoreInternals({\n      disableImmer,\n      initialState: state,\n      injections,\n      model: modelDefinition,\n      reducerEnhancer,\n      references,\n    });\n  };\n\n  const mockActionsMiddleware = () => () => action => {\n    if (action != null) {\n      mockedActions.push(action);\n    }\n    return undefined;\n  };\n\n  const composeEnhancers =\n    compose ||\n    (devTools &&\n    typeof window !== 'undefined' &&\n    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\n      ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({\n          name: storeName,\n        })\n      : reduxCompose);\n\n  bindStoreInternals(initialState);\n\n  const easyPeasyMiddleware = [\n    createComputedPropertiesMiddleware(references),\n    reduxThunk,\n    ...middleware,\n    createListenerMiddleware(references),\n    persistMiddleware,\n  ];\n\n  if (mockActions) {\n    easyPeasyMiddleware.push(mockActionsMiddleware);\n  }\n\n  const store = reduxCreateStore(\n    references.internals.reducer,\n    references.internals.defaultState,\n    composeEnhancers(applyMiddleware(...easyPeasyMiddleware), ...enhancers),\n  );\n\n  store.subscribe(() => {\n    references.internals.computedState.isInReducer = false;\n  });\n\n  references.dispatch = store.dispatch;\n  references.getState = store.getState;\n\n  const bindActionCreators = () => {\n    Object.keys(store.dispatch).forEach(actionsKey => {\n      delete store.dispatch[actionsKey];\n    });\n    Object.keys(references.internals.actionCreators).forEach(key => {\n      store.dispatch[key] = references.internals.actionCreators[key];\n    });\n  };\n\n  bindActionCreators();\n\n  const rebindStore = removeKey => {\n    const currentState = store.getState();\n    if (removeKey) {\n      delete currentState[removeKey];\n    }\n    bindStoreInternals(currentState);\n    store.replaceReducer(references.internals.reducer);\n    replaceState(references.internals.defaultState);\n    bindActionCreators();\n  };\n\n  const resolveRehydration = rehydrateStateFromPersistIfNeeded(\n    persistKey,\n    replaceState,\n    references,\n  );\n\n  return Object.assign(store, {\n    addModel: (key, modelForKey) => {\n      if (modelDefinition[key] && process.env.NODE_ENV !== 'production') {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `easy-peasy: The store model already contains a model definition for \"${key}\"`,\n        );\n        store.removeModel(key);\n      }\n      modelDefinition[key] = modelForKey;\n      rebindStore();\n    },\n    clearMockedActions: () => {\n      mockedActions = [];\n    },\n    getActions: () => references.internals.actionCreators,\n    getListeners: () => references.internals.listenerActionCreators,\n    getMockedActions: () => [...mockedActions],\n    persist: {\n      clear: clearPersistance,\n      flush: () => persistor.flush(),\n      resolveRehydration: () => resolveRehydration,\n    },\n    reconfigure: newModel => {\n      modelDefinition = bindReplaceState(newModel);\n      rebindStore();\n    },\n    removeModel: key => {\n      if (!modelDefinition[key]) {\n        if (process.env.NODE_ENV !== 'production') {\n          // eslint-disable-next-line no-console\n          console.warn(\n            `easy-peasy: The store model does not contain a model definition for \"${key}\"`,\n          );\n        }\n        return;\n      }\n      delete modelDefinition[key];\n      rebindStore(key);\n    },\n  });\n}\n","import createReducer from './create-reducer';\nimport extractDataFromModel from './extract-data-from-model';\n\nexport default function createStoreInternals({\n  disableImmer,\n  initialState,\n  injections,\n  model,\n  reducerEnhancer,\n  references,\n}) {\n  const {\n    actionCreatorDict,\n    actionCreators,\n    actionReducersDict,\n    computedState,\n    computedProperties,\n    customReducers,\n    defaultState,\n    listenerActionCreators,\n    listenerActionMap,\n    persistenceConfig,\n  } = extractDataFromModel(model, initialState, injections, references);\n\n  const rootReducer = createReducer(\n    disableImmer,\n    actionReducersDict,\n    customReducers,\n    computedProperties,\n  );\n\n  return {\n    actionCreatorDict,\n    actionCreators,\n    computedProperties,\n    computedState,\n    defaultState,\n    listenerActionCreators,\n    listenerActionMap,\n    persistenceConfig,\n    reducer: reducerEnhancer(rootReducer),\n  };\n}\n","import { setAutoFreeze } from 'immer-peasy';\nimport {\n  createTypedHooks,\n  useStoreActions,\n  useStoreDispatch,\n  useStoreState,\n  useStoreRehydrated,\n  useStore,\n} from './hooks';\nimport createStore from './create-store';\nimport createContextStore from './create-context-store';\nimport createComponentStore from './create-component-store';\nimport createTransform from './create-transform';\nimport StoreProvider from './provider';\nimport {\n  action,\n  actionOn,\n  computed,\n  debug,\n  memo,\n  persist,\n  reducer,\n  thunk,\n  thunkOn,\n} from './helpers';\n\n/**\n * The auto freeze feature of immer doesn't seem to work in our testing. We have\n * explicitly disabled it to avoid perf issues.\n */\nsetAutoFreeze(false);\n\nexport {\n  action,\n  actionOn,\n  computed,\n  createComponentStore,\n  createContextStore,\n  createStore,\n  createTransform,\n  createTypedHooks,\n  debug,\n  memo,\n  persist,\n  reducer,\n  StoreProvider,\n  thunk,\n  thunkOn,\n  useStoreActions,\n  useStoreDispatch,\n  useStoreState,\n  useStoreRehydrated,\n  useStore,\n};\n","import React from 'react';\nimport StoreContext from './context';\n\nexport default function StoreProvider({ children, store }) {\n  return (\n    <StoreContext.Provider value={store}>{children}</StoreContext.Provider>\n  );\n}\n","import { useMemo, useState, useRef, useEffect } from 'react';\nimport createStore from './create-store';\n\n/**\n * Some good references on the topic of reinitialisation:\n * - https://github.com/facebook/react/issues/14830\n */\n\nexport default function createComponentStore(model, config) {\n  return function useLocalStore(initialData) {\n    const store = useMemo(\n      () =>\n        createStore(\n          typeof model === 'function' ? model(initialData) : model,\n          config,\n        ),\n      [],\n    );\n    const previousStateRef = useRef(store.getState());\n    const [currentState, setCurrentState] = useState(() => store.getState());\n    useEffect(() => {\n      return store.subscribe(() => {\n        const nextState = store.getState();\n        if (previousStateRef.current !== nextState) {\n          previousStateRef.current = nextState;\n          setCurrentState(nextState);\n        }\n      });\n    }, [store]);\n    return [currentState, store.getActions()];\n  };\n}\n","/* eslint-disable react/prop-types */\n\nimport React, { createContext, useContext, useMemo } from 'react';\nimport {\n  createStoreActionsHook,\n  createStoreDispatchHook,\n  createStoreStateHook,\n  createStoreRehydratedHook,\n} from './hooks';\nimport createStore from './create-store';\n\nexport default function createContextStore(model, config) {\n  const StoreContext = createContext();\n\n  function Provider({ children, initialData }) {\n    const store = useMemo(\n      () =>\n        createStore(\n          typeof model === 'function' ? model(initialData) : model,\n          config,\n        ),\n      [],\n    );\n    return (\n      <StoreContext.Provider value={store}>{children}</StoreContext.Provider>\n    );\n  }\n\n  function useStore() {\n    return useContext(StoreContext);\n  }\n\n  return {\n    Provider,\n    useStore,\n    useStoreState: createStoreStateHook(StoreContext),\n    useStoreActions: createStoreActionsHook(StoreContext),\n    useStoreDispatch: createStoreDispatchHook(StoreContext),\n    useStoreRehydrated: createStoreRehydratedHook(StoreContext),\n  };\n}\n","/**\n * This file has been copied from redux-persist.\n * The intention being to support as much of the redux-persist API as possible.\n */\n\nexport default function createTransform(inbound, outbound, config = {}) {\n  const whitelist = config.whitelist || null;\n  const blacklist = config.blacklist || null;\n\n  function whitelistBlacklistCheck(key) {\n    if (whitelist && whitelist.indexOf(key) === -1) return true;\n    if (blacklist && blacklist.indexOf(key) !== -1) return true;\n    return false;\n  }\n\n  return {\n    in: (data, key, fullState) =>\n      !whitelistBlacklistCheck(key) && inbound\n        ? inbound(data, key, fullState)\n        : data,\n    out: (data, key, fullState) =>\n      !whitelistBlacklistCheck(key) && outbound\n        ? outbound(data, key, fullState)\n        : data,\n  };\n}\n"],"names":["StoreContext","createContext","useIsomorphicLayoutEffect","window","useLayoutEffect","useEffect","createStoreStateHook","Context","mapState","equalityFn","store","useContext","mapStateRef","useRef","stateRef","mountedRef","subscriptionMapStateError","forceRender","useReducer","s","current","undefined","getState","err","checkMapState","newState","unsubscribe","subscribe","useStoreState","EasyPeasyContext","createStoreActionsHook","mapActions","getActions","useStoreActions","createStoreDispatchHook","dispatch","useStoreDispatch","useStore","createStoreRehydratedHook","useState","rehydrated","setRehydrated","persist","resolveRehydration","then","useStoreRehydrated","actionSymbol","actionOnSymbol","computedSymbol","persistSymbol","reducerSymbol","thunkOnSymbol","thunkSymbol","action","fn","defaultStateResolvers","state","deepCloneStateWithoutComputed","source","recursiveClone","next","Object","keys","reduce","acc","key","getOwnPropertyDescriptor","get","forEach","isPlainObject","isPromise","x","path","target","cur","set","value","length","idx","createSimpleProduce","disableImmer","newify","currentPath","currentState","finalValue","slice","draft","createDraft","result","isDraft","finishDraft","parentPath","parent","createReducer","actionReducersDict","customReducers","computedProperties","reducerForActions","actionReducer","type","actionMeta","simpleProduce","payload","stateAfterActions","red","reducer","bindComputedProperty","prop","noopStorage","getItem","setItem","removeItem","getStorage","storageName","_","localStorage","sessionStorage","createStorageWrapper","storage","transformers","deserialize","data","simpleKey","substr","indexOf","JSON","parse","outTransformers","out","reverse","isAsync","wrapped","transformed","in","stringify","resolvePersistTargets","whitelist","blacklist","targets","findIndex","rehydrateStateFromPersistIfNeeded","persistKey","replaceState","references","Promise","resolve","internals","persistenceConfig","persistInstance","applyRehydrationStrategy","originalState","rehydratedState","mergeStrategy","setAt","currentTarget","currentNext","config","defaultState","asyncStateResolvers","targetPath","dataPromise","push","all","map","resolvedData","createActionCreator","actionDefinition","meta","join","actionName","actionCreator","resolvedTargets","createThunkActionsCreator","thunkDefinition","thunkHandler","startType","successType","failType","thunkMeta","dispatchError","error","dispatchSuccess","resolved","catch","extractDataFromModel","model","initialState","injections","actionCreators","actionCreatorDict","listenerActionMap","actionThunks","listenerActionCreators","listenerDefinitions","computedState","isInReducer","recursiveExtractFromModel","handleValueAsState","initialParentRef","persistDefinition","definition","computedMeta","memoisedResultFn","helpers","getStoreActions","getStoreState","memoizerific","o","defineProperty","configurable","enumerable","storeState","inputs","stateResolvers","resolver","listenerActionOrThunk","listenerMeta","targetResolver","targetTypes","Array","isArray","targetType","listenerReg","createStore","options","bindReplaceState","modelDef","ePRS","storeName","nextState","bindStoreInternals","reducerEnhancer","modelDefinition","persistor","modelClone","compose","devTools","enhancers","middleware","mockActions","name","rootReducer","mockedActions","debounce","persistMiddleware","clearPersistance","reject","composeEnhancers","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","reduxCompose","easyPeasyMiddleware","reduxThunk","sourceAction","reduxCreateStore","applyMiddleware","bindActionCreators","actionsKey","rebindStore","removeKey","replaceReducer","assign","addModel","modelForKey","clearMockedActions","getListeners","getMockedActions","clear","flush","reconfigure","newModel","removeModel","children","React","Provider","fnOrStateResolvers","initialData","useMemo","previousStateRef","setCurrentState","inbound","outbound","whitelistBlacklistCheck","fullState","original","cacheSize"],"mappings":"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"}